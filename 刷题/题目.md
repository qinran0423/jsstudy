

## 第一天

1. 编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1。

   ```js
   function sort1(k, arr) {
    return Array.from(new Set([...arr])).sort((a, b) => b-a)[k-1]
    }
   ```

2. `__proto__`和 prototype 之前有什么关系？

   每一个function都会有个prototype属性,这个属性是个对象，代表这个函数的原型。通过new一个构造函数返回一个实例，这个实例有一个属性`__proto__`指向了function的prototype.

3. .call(), .apply() .bind() 的区别和作用？bind 方法如何来实现？

   相同点：
   这三个方法其实都是改变this指向的，第一个参数都是想要把this指向的目标对象
   不同点：
   .call() 和 .apply()在内部执行了调用它的的函数。但是这两个函数的传参方式不一样。
     .call是一个指定this值和后面可以是一个也可以是多个参数组成
     .apply是一个指定this值和一个数组组成
   .bind则返回一个函数，参数由bind的后续参数和bind返回的函数的参数组成

```js
Function.prototype.myBind = function (ctx) {
  const originFn = this
  const args = [].slice.call(arguments, 1)
  const newFn =  function () {
    const newargs = [].slice.call(arguments)
    originFn.apply(this instanceof newFn ? this : ctx, args.concat(newargs))
  }
  
  newFn.prototype = Object.create(this.prototype)

  return newFn
}
```

### 附加作业

1. js中基础数据类型有哪几种?了解包装对象么？

   boolean, null , undefined, number, string, symbol

   基础数据类型都是值，没有办法提供调用的“abc”.split("")确实被允许的，是因为js中会存在包装对象，会把字符串先包装成对象然后在调用对象下的一些方法，方法调用完成之后则销毁对象，就完成了基础数据类型的函数调用

2. 如何判断this？箭头函数的this是什么？

   1. 函数直接调用this

      ```js
      function foo(){
          console.log(this);
      }
      foo();
      ```

      this会指向window,严格模式下this是undefined,同样也需要注意在script标签type="module"也是undefined

   2. 对象里调用

      ```js
       let obj = {
          myname:"对象",
          foo:function(){
              console.log(this);
          }
      }
      obj.foo(); //this会指向调用的对象
      ```

   3. 在构造函数及类中this会指向实例化对象

      ```js
      function Super(){
          this.name = "Randy";
      }
      Super.prototype.foo = function(){
          console.log(this);
      }
      
      let sup = new Super();
      sup.foo(); //this指向实例化对象zhangsan
      
      
      class Animal{
          constructor(name){
              this.name = name;
          }
          foo(){
              console.log(this);
          }
      }
      
      let xiaoqiang = new Animal("小强");
      xiaoqiang.foo(); //this 会指向xiaoqiang
      ```

## 第二天

1. 如何中断ajax请求？

   + 设置超时时间让ajax自动断开
   + 手动停止ajax请求，调用XMLHttpRequest对象上的abort方法

2. 什么是同步？什么是异步？

   同步：

   在发送一个请求之后，需要等待服务器响应返回，才能够发送下一个请求

   缺点：

   + 请求必须等待响应，如果遇到请求阻塞，网络延迟，用户需要等待，用户体验不好
   + 请求是会携带所有的信息

   异步：

   异步不需要等待响应，随时可以发送下一次请求。

3. 什么是宏任务？什么是微任务？

   微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，

   宏任务：包括整体代码script, setTimeout, setInterval, setImmediate

   微任务：Promise,process.nextTick,MutationObserver 

   在事件循环中，首先进入整体script，即首先进入宏任务，执行结束之后，查找有没有可执行的微任务，有的话则执行微任务，执行完毕后刷新浏览器。开始新的宏任务。所以当一个宏任务完成后，主线程会询问有没有微任务需要处理，只能处理完了当前所有的微任务，才会开始下一个宏任务

### 附加题

1. 什么是回调?回调使用中存在什么问题?

   把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，就是回调

   回调会导致隐式绑定this的指向问题

2. .Promise.allSettled 了解吗？动手实现一下 Promise.allSettled?

   Promise.allSettled()返回一个在所有给定的promise都已经fulfilled或者rejected后的promise,并带有一个对象数组，每个对象表示对应的promise结果

   ```js
   function allSettled(iterable) {
     return new Promise((resolve, reject) => {
       function addElementToResult(i, elem) {
         result[i] = elem;
         elementCount++;
         if (elementCount === result.length) {
           resolve(result);
         }
       }
   
       let index = 0;
       for (const promise of iterable) {
         // Capture the current value of `index`
         const currentIndex = index;
         promise.then(
           (value) => addElementToResult(
             currentIndex, {
               status: 'fulfilled',
               value
             }),
           (reason) => addElementToResult(
             currentIndex, {
               status: 'rejected',
               reason
             }));
         index++;
       }
       if (index === 0) {
         resolve([]);
         return;
       }
       let elementCount = 0;
       const result = new Array(index);
     });
   }
   ```

   

## 第三天

1.  vue 中组件间有哪些通信方式?

   + 父子组件通信- 父组件通过props传递数据给子组件，子组件通过emit发送事件传递数。据给父组件这种父子通信方式也就是典型的单向数据流，父组件通过props传递数据，子组件不能直接修改props，而是必须通过发送事件的方式告知父组件修改数据。
   + 兄弟组件通信- 就是this.$parent.$children，在$children中可以通过组件name查询到需要的组件实例，然后进行通信。
   + 跨多层次组件通信-provide/inject
   + 任意组件通信-这种方式可以通过 Vuex 或者 Event Bus 解决

2. vue 中 v-show 和 v-if 的区别是什么？

   v-show只是在display:none和display:block之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说v-show在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。

   v-if的话就得说到 Vue 底层的编译了。当属性初始为false时，组件就不会被渲染，直到条件为true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。并且基于v-if的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。

3. keep-alive 组件有什么作用？

   如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用keep-alive组件包裹需要保存的组件。对于keep-alive组件来说，它拥有两个独有的生命周期钩子函数，分别为activated和deactivated。用keep-alive包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行deactivated钩子函数，命中缓存渲染后会执行actived钩子函数。